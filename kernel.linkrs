local PAGE_SIZE = 64K; // local - symbol for local use in script only
local PHYS_LOAD_ADDR = 0x8_0000;

export __KERNEL_VIRT_BASE = 0xffff_ffff_0000_0000; // export - publish symbol in exe file

Section("init_thread_stack", .rw + .NoFileContent) {
    MemoryView {
        .base = 0x0; // sets LMA = VMA = 0x0
        .size = PHYS_LOAD_ADDR; // Set section size to a fixed value
    }
    Contents {
        export __INIT_THREAD_START = @;
        export __STACK_BOTTOM = @;

        advance(PHYS_LOAD_ADDR, PAGE_SIZE); // Move @ by argument, optionally align by second argument.
        // Equiv. to `@ = advanced(PHYS_LOAD_ADDR); @ = aligned(@, PAGE_SIZE);`

        export __STACK_TOP = @;
    }
}

Section("init_thread_text", .rx) {
    MemoryView {
        .base = PHYS_LOAD_ADDR; // LMA = VMA = 0x8_0000
    }
    FileView {
        .base = File.Origin; // in file we need to mark this "first loaded section, lowest file address"
    }
    Contents {
        keep(all(".text.main.entry"));
        all(".text.boot");
        all(".data.boot");

        align(PAGE_SIZE); // equivalent to `@ = aligned(@, PAGE_SIZE);`

        export __INIT_THREAD_END = @; /* Here the boot code ends */
    }
}

// This section lives at two addresses, LMA is directly after init_thread_text, but VMA is at __KERNEL_VIRT_BASE
Section("nucleus_text", .rx) {
    MemoryView {
        .base = follow("init_thread_text");
        .vma = __KERNEL_VIRT_BASE;
    }
    // FileView essentially mimics MemoryView so can be skipped..
    Contents {
        matching(".text*");

        align(2048);

        export __EXCEPTION_VECTORS_START = @;
        keep(all(.vectors));
    }
    NoCrossRefs("init_thread_text", "init_thread_stack");
}

// The default for section is to follow(previous_section) so it doesn't need to be specified
Section("nucleus_rodata", .ro, start_align(4)) {
    Contents {
        matching(".rodata*");
        fill(0x00);
    }
    NoCrossRefs("init_thread_text", "init_thread_stack");
}

Section("nucleus_rwdata", .rw, start_align(PAGE_SIZE)) {
    Contents {
        matching(".data*");
        fill(0x00);
    }
    NoCrossRefs("init_thread_text", "init_thread_stack");
}

Section("nucleus_bss", .rw + .NoFileContent, start_align(PAGE_SIZE)) {
    Contents {
        export _BSS_START = @.lma; // Phys address of bss area
        all(.bss*);
        export _BSS_END = @.lma; // Phys address of bss area
    }
}

/* Exceptions linker script merely provides symbols */

provide(current_el0_synchronous   = current_el0_synchronous);
provide(current_el0_irq           = current_el0_irq);
provide(current_el0_fiq           = default_exception_handler);
provide(current_el0_serror        = current_el0_serror);

provide(current_elx_synchronous   = current_elx_synchronous);
provide(current_elx_irq           = current_elx_irq);
provide(current_elx_fiq           = default_exception_handler);
provide(current_elx_serror        = current_elx_serror);

provide(lower_aarch64_synchronous = lower_aarch64_synchronous);
provide(lower_aarch64_irq         = lower_aarch64_irq);
provide(lower_aarch64_fiq         = default_exception_handler);
provide(lower_aarch64_serror      = lower_aarch64_serror);

provide(lower_aarch32_synchronous = lower_aarch32_synchronous);
provide(lower_aarch32_irq         = lower_aarch32_irq);
provide(lower_aarch32_fiq         = default_exception_handler);
provide(lower_aarch32_serror      = lower_aarch32_serror);
