const PAGE_SIZE: usize = 64K;
const PHYS_LOAD_ADDR: Address = 0x8_0000;

pub const KERNEL_VIRT_BASE: Address = 0xffff_ffff_0000_0000;

output {
    entry: PHYS_LOAD_ADDR,
    arch: AArch64,
    also_generate: [Binary],
}

/// Initial kernel stack - reserved physical memory below load address
/// This section has no file content, just reserves address space
section init_thread_stack {
    permissions: Read | Write,
    occupies_file_space: false,

    address {
        start: 0x0,
        size: 0x8_0000,
    }

    contents {
        pub symbol __INIT_THREAD_START = here();
        pub symbol __STACK_BOTTOM = here();

        advance_by(PHYS_LOAD_ADDR);
        align_to(PAGE_SIZE);

        pub symbol __STACK_TOP = here();
    }
}

/// Early boot code that runs with MMU off (identity mapped)
section init_thread_text {
    permissions: Read | Execute,

    address {
        start: PHYS_LOAD_ADDR,
    }

    file_position {
        start: Origin,  // First loadable content in file
    }

    contents {
        keep(input(.text.main.entry))
        input(.text.boot)
        input(.data.boot)

        align_to(PAGE_SIZE);

        pub symbol __INIT_THREAD_END = here();
    }
}

/// Main kernel code - runs at high virtual address
/// Physical address follows init_thread_text, but virtual address
/// is at KERNEL_VIRT_BASE (for when MMU is enabled)
section nucleus_text {
    permissions: Read | Execute,

    address {
        follows: init_thread_text,      // LMA
        virtual_base: KERNEL_VIRT_BASE, // VMA
    }

    contents {
        input(.text*)

        align_to(2048);

        pub symbol __EXCEPTION_VECTORS_START = here();
        keep(input(.vectors))
    }

    /// This sections must not reference listed sections
    assert_no_cross_references_to(init_thread_text, init_thread_stack);
}

section nucleus_rodata {
    permissions: Read,

    address {
        alignment: 4,
    }

    contents {
        input(.rodata*)
        fill_padding_with(0x00)
    }

    assert_no_cross_references_to(init_thread_text, init_thread_stack);
}

section nucleus_rwdata {
    permissions: Read | Write,

    address {
        alignment: PAGE_SIZE,
    }

    contents {
        input(.data*)
        fill_padding_with(0x00)
    }

    assert_no_cross_references_to(init_thread_text, init_thread_stack);
}

section nucleus_bss {
    permissions: Read | Write,
    occupies_file_space: false,

    address {
        alignment: PAGE_SIZE,
    }

    contents {
        pub symbol __BSS_START = here().physical;
        input(.bss*)
        pub symbol __BSS_END = here().physical;
    }
}

/// Weak symbol definitions for exception handlers
/// If not defined elsewhere, these provide defaults
provide_symbols {
    current_el0_synchronous   = current_el0_synchronous,
    current_el0_irq           = current_el0_irq,
    current_el0_fiq           = default_exception_handler,
    current_el0_serror        = current_el0_serror,

    current_elx_synchronous   = current_elx_synchronous,
    current_elx_irq           = current_elx_irq,
    current_elx_fiq           = default_exception_handler,
    current_elx_serror        = current_elx_serror,

    lower_aarch64_synchronous = lower_aarch64_synchronous,
    lower_aarch64_irq         = lower_aarch64_irq,
    lower_aarch64_fiq         = default_exception_handler,
    lower_aarch64_serror      = lower_aarch64_serror,

    lower_aarch32_synchronous = lower_aarch32_synchronous,
    lower_aarch32_irq         = lower_aarch32_irq,
    lower_aarch32_fiq         = default_exception_handler,
    lower_aarch32_serror      = lower_aarch32_serror,
}
